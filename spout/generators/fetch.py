"""Fetch-based TypeScript client generator."""

from typing import List

from .base import BaseClientGenerator
from ..models.endpoint import Endpoint, ParameterType


class FetchClientGenerator(BaseClientGenerator):
    """Generator for fetch-based TypeScript clients."""

    def generate(self, endpoints: List[Endpoint]) -> str:
        """Generate fetch-based TypeScript client."""
        parts = [
            "// Generated TypeScript client using fetch API",
            "// This file was automatically generated by Spout",
            "",
        ]

        # Add types if requested
        types_section = self._generate_types(endpoints)
        if types_section:
            parts.append(types_section)

        # Add configuration interface
        parts.extend(
            [
                "export interface ApiConfig {",
                f"  baseUrl?: string;",
                "  headers?: Record<string, string>;",
                "  timeout?: number;",
                "}",
                "",
                "export class ApiClient {",
                "  private config: ApiConfig;",
                "",
                "  constructor(config: ApiConfig = {}) {",
                f"    this.config = {{ baseUrl: '{self.base_url}', ...config }};",
                "  }",
                "",
            ]
        )

        # Add utility methods
        parts.extend(
            [
                "  private async request<T>(",
                "    path: string,",
                "    options: RequestInit = {}",
                "  ): Promise<T> {",
                "    const url = `${this.config.baseUrl}${path}`;",
                "    const headers = {",
                "      'Content-Type': 'application/json',",
                "      ...this.config.headers,",
                "      ...options.headers,",
                "    };",
                "",
                "    const response = await fetch(url, {",
                "      ...options,",
                "      headers,",
                "    });",
                "",
                "    if (!response.ok) {",
                "      throw new Error(`HTTP error! status: ${response.status}`);",
                "    }",
                "",
                "    return response.json();",
                "  }",
                "",
            ]
        )

        # Generate methods for each endpoint
        for endpoint in endpoints:
            method_code = self._generate_endpoint_method(endpoint)
            parts.append(method_code)
            parts.append("")

        parts.append("}")

        return "\n".join(parts)

    def _generate_endpoint_method(self, endpoint: Endpoint) -> str:
        """Generate a method for a single endpoint."""
        method_name = self._sanitize_method_name(endpoint.typescript_method_name)

        # Separate parameters by type
        path_params = [
            p for p in endpoint.parameters if p.parameter_type == ParameterType.PATH
        ]
        query_params = [
            p for p in endpoint.parameters if p.parameter_type == ParameterType.QUERY
        ]
        body_params = [
            p for p in endpoint.parameters if p.parameter_type == ParameterType.BODY
        ]

        # Build parameter list
        params = []
        for param in path_params + query_params:
            optional = "?" if not param.required else ""
            params.append(f"{param.name}{optional}: {param.type}")

        if body_params:
            # For body parameters, create a single data object
            if len(body_params) == 1:
                param = body_params[0]
                optional = "?" if not param.required else ""
                params.append(f"data{optional}: {param.type}")
            else:
                # Multiple body parameters - create an object type
                body_props = []
                for param in body_params:
                    optional = "?" if not param.required else ""
                    body_props.append(f"{param.name}{optional}: {param.type}")
                params.append(f"data: {{ {'; '.join(body_props)} }}")

        param_str = ", ".join(params)

        # Determine return type
        if endpoint.responses:
            return_type = endpoint.responses[0].type
        else:
            return_type = "any"

        # Build method signature
        lines = []
        if endpoint.description:
            lines.append(f"  /**")
            lines.append(f"   * {endpoint.description}")
            lines.append(f"   */")

        lines.append(f"  async {method_name}({param_str}): Promise<{return_type}> {{")

        # Build path with parameter substitution
        path = endpoint.path
        for param in path_params:
            path = path.replace(f"{{{param.name}}}", f"${{{param.name}}}")

        lines.append(f"    let path = `{path}`;")

        # Add query parameters
        if query_params:
            lines.append("    const params = new URLSearchParams();")
            for param in query_params:
                if param.required:
                    lines.append(
                        f"    params.append('{param.name}', String({param.name}));"
                    )
                else:
                    lines.append(f"    if ({param.name} !== undefined) {{")
                    lines.append(
                        f"      params.append('{param.name}', String({param.name}));"
                    )
                    lines.append("    }")
            lines.append("    const queryString = params.toString();")
            lines.append("    if (queryString) path += `?${queryString}`;")
            lines.append("")

        # Build request options
        method = endpoint.method.value
        lines.append("    const options: RequestInit = {")
        lines.append(f"      method: '{method}',")

        if body_params:
            lines.append("      body: JSON.stringify(data),")

        lines.append("    };")
        lines.append("")
        lines.append(f"    return this.request<{return_type}>(path, options);")
        lines.append("  }")

        return "\n".join(lines)
